---
layout: post
title: "sinagong roadmap and programming language"
name: "FriJun07"
tags: [shcool]
permalink: 2024-06-07-22th.html
sidebar: other_sidebar
folder: 2024
collection: wiki
categories: school
keywords: "lic sinagong IEIP"
summary: "FriJun07, license for Information Management Industrial Engineer"
excerpt_separator: <!--more-->
toc: true
public: true
parent: [[Wiki-Setting-Category]] 
date: 2024-06-07T16:05:30 +0900
updated: 2024-06-07 16:05
---
* TOC
{:toc}

AI summarized youtube contents based on the subtitles.
[Playlist](https://www.youtube.com/playlist?list=PLpYNFXUfkvDqw4OEJNGts5NiGG3iQ40pp)

[membox](https://membox.co.kr/lesson/elsAuw) onofftony aiegoo@na


## C Structure
C 언어에서 구조체는 여러 변수를 묶어 하나의 사용자 정의 타입을 만드는 방법입니다. 이를 통해 복잡한 데이터를 간편하게 관리할 수 있습니다. 예를 들어, 사람을 표현하는 구조체를 만들어보겠습니다.

```c
#include <stdio.h>

// 사람을 표현하는 구조체 선언
struct Person {
    char *name;  // 이름을 저장할 문자열 포인터
    int age;     // 나이를 저장할 정수형 변수
    float height; // 키를 저장할 실수형 변수
};

int main() {
    // 구조체 변수 선언 및 초기화
    struct Person user1;
    
    // 구조체 멤버에 값 할당
    user1.name = "Hug";
    user1.age = 25;
    user1.height = 175.5;

    // 구조체 멤버 출력
    printf("Name: %s\n", user1.name);
    printf("Age: %d\n", user1.age);
    printf("Height: %.2f\n", user1.height);

    return 0;
}
```

이 예제에서는 `Person`이라는 구조체를 선언하고, `name`, `age`, `height`라는 세 개의 멤버 변수를 포함했습니다. 그런 다음 `user1`이라는 구조체 변수를 선언하고, 각 멤버 변수에 값을 할당한 후 출력합니다.

구조체를 포인터와 함께 사용할 때는 `->` 연산자를 사용합니다. 이를 통해 구조체의 멤버에 접근할 수 있습니다.

```c
#include <stdio.h>

// 구조체 정의
struct Person {
    char *name;
    int age;
    float height;
};

int main() {
    // 구조체 변수 선언
    struct Person user1;
    struct Person *pUser;

    // 포인터 변수에 구조체 변수 주소 할당
    pUser = &user1;

    // 포인터를 이용한 구조체 멤버 접근 및 값 할당
    pUser->name = "Hug";
    pUser->age = 25;
    pUser->height = 175.5;

    // 포인터를 이용한 구조체 멤버 출력
    printf("Name: %s\n", pUser->name);
    printf("Age: %d\n", pUser->age);
    printf("Height: %.2f\n", pUser->height);

    return 0;
}
```

이 예제에서는 `Person` 구조체에 대한 포인터 `pUser`를 선언하고, `user1` 구조체 변수의 주소를 할당합니다. `pUser` 포인터를 통해 `->` 연산자를 사용하여 `user1`의 멤버 변수에 접근하고 값을 할당한 후 출력합니다.

구조체와 포인터를 사용하는 것은 메모리 주소를 직접 다룰 수 있어 유연성과 효율성을 높여줍니다. 하지만 포인터를 사용할 때는 메모리 관리와 관련된 오류를 주의해야 합니다.

### Java data tupes

Java에서 사용할 수 있는 데이터 타입에는 크게 문자, 정수, 실수, 논리 이렇게 네 가지 종류로 나눌 수 있습니다.

### 문자 타입
- **char**: 
  - 크기: 2바이트 (16비트)
  - 표현 범위: 0부터 65535까지 (총 65536가지)

### 정수 타입
- **byte**:
  - 크기: 1바이트 (8비트)
  - 표현 범위: -128부터 127까지 (총 256가지, 양수와 음수를 포함하여 절반씩 나누기)

- **short**:
  - 크기: 2바이트 (16비트)
  - 표현 범위: -32768부터 32767까지 (총 65536가지, 양수와 음수를 포함하여 절반씩 나누기)

- **int**:
  - 크기: 4바이트 (32비트)
  - 표현 범위: 약 -21억 4748만 3648부터 21억 4748만 3647까지

- **long**:
  - 크기: 8바이트 (64비트)
  - 표현 범위: 약 -922경 3372조 3685억 4775만 808부터 922경 3372조 3685억 4775만 807까지

### 실수 타입
- **float**:
  - 크기: 4바이트
  - 표현 범위: 단정도 부동 소수점 (IEEE 754 표준)

- **double**:
  - 크기: 8바이트
  - 표현 범위: 배정도 부동 소수점 (IEEE 754 표준)

### 논리 타입
- **boolean**:
  - 크기: 1바이트
  - 표현 값: `true` 또는 `false`

### 요약
자바의 데이터 타입은 크기와 표현할 수 있는 값의 범위에 따라 다양하게 나뉘어져 있으며, 각 타입마다 사용하는 메모리의 크기가 다릅니다. 이러한 타입들은 프로그래밍 시 데이터를 적절히 저장하고 처리하는 데 중요한 역할을 합니다. 특히, C 언어와 비교해보면 몇 가지 타입은 동일하지만, 크기나 표현 범위에서 차이가 나는 경우도 있습니다. 이를 잘 기억하고 각 상황에 맞는 데이터 타입을 사용하는 것이 중요합니다.



```markdown
| Data Type | Size (Bytes) | Size (Bits) | Range                                                                 |
|-----------|--------------|-------------|----------------------------------------------------------------------|
| `char`    | 2            | 16          | 0 to 65535                                                           |
| `byte`    | 1            | 8           | -128 to 127                                                          |
| `short`   | 2            | 16          | -32768 to 32767                                                      |
| `int`     | 4            | 32          | -2,147,483,648 to 2,147,483,647                                      |
| `long`    | 8            | 64          | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807              |
| `float`   | 4            | 32          | Approximately ±3.40282347E+38F (6-7 significant decimal digits)       |
| `double`  | 8            | 64          | Approximately ±1.79769313486231570E+308 (15 significant decimal digits) |
| `boolean` | 1            | 8           | `true` or `false`                                                    |
```

This table provides a clear and concise reference for Java data types, their sizes in bytes and bits, and the ranges of values they can represent.

## Python data type
Here's the table summarizing the data types, their sizes, and ranges in Python based on the provided information:

```markdown
| Sub-category       | Data Type | Size (Bytes) | Size (Bits) | Range                                      |
|--------------------|-----------|--------------|-------------|--------------------------------------------|
| String             | `str`     | Unlimited    | Unlimited   | Limited by available memory                |
| Integer            | `int`     | Unlimited    | Unlimited   | Limited by available memory                |
| Floating-point     | `float`   | 8            | 64          | Approximately ±1.7976931348623157e+308     |
| Complex numbers    | `complex` | 16           | 128         | Real and imaginary parts are both floats   |
```

- **String** (`str`): The size and range are only limited by the available memory on the system.
- **Integer** (`int`): The size and range are also only limited by the available memory.
- **Floating-point** (`float`): Uses 8 bytes (64 bits) to store a floating-point number.
- **Complex numbers** (`complex`): Uses 16 bytes (128 bits) to store a complex number, with 8 bytes each for the real and imaginary parts.

## 예약어
프로그래밍 언어에서 **예약어**(reserved words)는 특별한 의미를 가지며 특정한 기능을 수행하도록 정해진 단어들입니다. 이러한 예약어들은 변수 이름이나 다른 목적으로 사용할 수 없습니다. 이제 예약어의 종류와 예시를 살펴보겠습니다.

### 예약어의 종류와 예시

#### 1. 제어문 (Control Statements)
제어문은 프로그램의 흐름을 제어하는 데 사용됩니다.
- **예시**: `if`, `else`, `while`, `for`, `switch`, `case`, `break`, `continue`, `return`

#### 2. 자료형 (Data Types)
자료형 예약어는 변수나 함수의 타입을 정의할 때 사용됩니다.
- **예시**: `int`, `float`, `double`, `char`, `boolean`, `void`, `long`, `short`, `byte`

#### 3. 기억 클래스 (Storage Classes)
기억 클래스 예약어는 변수나 함수의 범위와 수명을 정의합니다.
- **예시**: `static`, `extern`, `register`, `auto`

#### 4. 기타 예약어 (Other Keywords)
기타 예약어는 다양한 목적으로 사용됩니다.
- **예시**: `class`, `public`, `private`, `protected`, `import`, `package`, `new`, `try`, `catch`, `finally`, `throw`, `throws`, `interface`, `extends`, `implements`, `enum`

### 요약

| **종류**       | **설명**                               | **예시**                                                                                   |
|----------------|----------------------------------------|--------------------------------------------------------------------------------------------|
| 제어문         | 프로그램의 흐름 제어                   | `if`, `else`, `while`, `for`, `switch`, `case`, `break`, `continue`, `return`               |
| 자료형         | 변수나 함수의 타입 정의                | `int`, `float`, `double`, `char`, `boolean`, `void`, `long`, `short`, `byte`                |
| 기억 클래스    | 변수나 함수의 범위와 수명 정의         | `static`, `extern`, `register`, `auto`                                                     |
| 기타 예약어    | 다양한 목적                            | `class`, `public`, `private`, `protected`, `import`, `package`, `new`, `try`, `catch`, `finally`, `throw`, `throws`, `interface`, `extends`, `implements`, `enum` |

프로그래밍 언어의 예약어는 각각의 언어마다 다를 수 있지만, 그 기능은 대체로 유사합니다. 예약어는 고유한 기능을 수행하도록 미리 정해져 있기 때문에, 이러한 단어들을 변수 이름이나 다른 목적으로 사용할 수 없습니다. 예약어를 이해하고 올바르게 사용하는 것은 프로그래밍의 기본이며, 코드의 가독성과 유지 보수성을 높이는 데 중요합니다.

## constants vs vairables
변수를 상수로 만들어 사용하는 방법에 대해 알아보겠습니다. 상수는 한 번 할당되면 변경되지 않는 값을 의미하며, 변수는 프로그램 실행 도중 값이 변할 수 있는 메모리 공간입니다. 상수를 사용하면 코드의 안정성과 가독성을 높일 수 있습니다. 다음은 변수와 상수에 대한 개념 및 사용 방법을 설명한 것입니다.

### 상수와 변수의 개념

- **변수**: 프로그램 실행 도중 값을 저장하고, 그 값이 변경될 수 있는 메모리 공간.
  - 예: `int a = 10;`에서 `a`는 변수이고, 초기값 `10`은 변할 수 있다.
  
- **상수**: 값이 변경되지 않는 메모리 공간.
  - 예: `const float PI = 3.14159;`에서 `PI`는 상수이고, 값 `3.14159`는 변하지 않는다.

### 상수 선언 방법

#### 예제 1: 상수 선언 (C 언어)
```c
const float PI = 3.14159;
```

- `const` 예약어를 사용하여 상수를 선언합니다.
- `PI`는 상수로, 값 `3.14159`는 변경되지 않습니다.

#### 예제 2: 데이터 타입 후 상수 선언 (C 언어)
```c
float const PI = 3.14159;
```

- 데이터 타입을 먼저 쓰고, `const` 예약어를 사용하여 상수를 선언할 수 있습니다.

### 상수의 장점
- **안정성**: 상수는 변경되지 않으므로 값이 의도치 않게 변하는 것을 방지합니다.
- **가독성**: 의미 있는 이름을 사용하여 코드의 가독성을 높입니다.
- **유지보수성**: 상수를 사용하면 값을 변경할 때 상수 선언 부분만 수정하면 되므로 유지보수가 용이합니다.

### 심볼릭 상수 (Symbolic Constants)
심볼릭 상수는 의미 있는 이름을 붙여 사용한 상수입니다. 예를 들어, `PI`라는 이름을 사용하여 원주율을 나타내는 상수를 만들 수 있습니다.

### 변수와 상수의 비교

| **종류** | **설명**                                                   | **예시**                  |
|----------|------------------------------------------------------------|---------------------------|
| 변수     | 값이 변경될 수 있는 메모리 공간                           | `int a = 10;`             |
| 상수     | 값이 변경되지 않는 메모리 공간                             | `const float PI = 3.14159;` |

### 요약
- 변수를 상수로 만들려면 `const` 예약어를 사용합니다.
- 상수는 변경되지 않는 값을 저장하여 코드의 안정성, 가독성, 유지보수성을 높입니다.
- 상수를 선언하는 두 가지 방법이 있습니다: `const`를 앞에 쓰거나 데이터 타입 뒤에 씁니다.
- 상수에 의미 있는 이름을 붙여 사용하는 것을 심볼릭 상수라고 합니다.

이러한 개념과 방법을 잘 이해하고 사용하면 프로그래밍에서 더 안정적이고 가독성 높은 코드를 작성할 수 있습니다.

## storage class
### 기억 클래스 (Storage Class)

기억 클래스는 변수가 메모리에서 어떻게 저장되고, 변수의 생명 주기와 범위(scope)가 어떻게 결정되는지를 정의합니다. C 언어에서는 주로 다섯 가지 기억 클래스가 사용됩니다: 자동 변수, 레지스터 변수, 정적 변수 (내부와 외부), 외부 변수입니다.

#### 1. 자동 변수 (Auto Variable)
- **예약어**: `auto` (생략 가능)
- **저장 위치**: 스택(Stack)
- **범위**: 해당 블록 또는 함수 내
- **생명 주기**: 블록이나 함수가 끝나면 소멸
- **특징**: 초기화하지 않으면 쓰레기 값이 저장될 수 있음

#### 2. 레지스터 변수 (Register Variable)
- **예약어**: `register`
- **저장 위치**: CPU 레지스터
- **범위**: 해당 블록 또는 함수 내
- **생명 주기**: 블록이나 함수가 끝나면 소멸
- **특징**: 주소 연산자(&) 사용 불가, 실행 속도 빠름, 제한된 개수만 사용 가능

#### 3. 정적 변수 (Static Variable)
- **예약어**: `static`
- **저장 위치**: 데이터 영역(Data Segment)
- **범위**: 내부 정적 변수는 해당 블록 또는 함수 내, 외부 정적 변수는 파일 내
- **생명 주기**: 프로그램 종료 시까지 유지
- **특징**: 초기화를 하지 않으면 자동으로 0으로 초기화

#### 4. 외부 변수 (Extern Variable)
- **예약어**: `extern`
- **저장 위치**: 데이터 영역(Data Segment)
- **범위**: 모든 파일에서 참조 가능
- **생명 주기**: 프로그램 종료 시까지 유지
- **특징**: 초기화를 하지 않으면 자동으로 0으로 초기화, 다른 파일에서 선언된 변수 참조 가능

### 전역 변수와 지역 변수
- **전역 변수 (Global Variable)**: 프로그램 전체에서 접근 가능, 함수 외부에서 선언
- **지역 변수 (Local Variable)**: 특정 블록 또는 함수 내에서만 접근 가능, 블록 또는 함수 내부에서 선언

### 예시 코드 분석

```c
#include <stdio.h>

// 전역 변수 선언
int x = 0;
int y = 0;

int main() {
    // 자동 변수 선언
    int a = 0;
    int b = 1;
    
    printf("%d %d\n", a, b); // 출력: 0 1
    
    {
        // 새로운 블록 내에서 자동 변수 선언
        int a = 2;
        int b = 3;
        
        printf("%d %d\n", a, b); // 출력: 2 3
    }
    
    // 외부 블록의 자동 변수는 여전히 유효
    printf("%d %d\n", a, b); // 출력: 0 1
    
    return 0;
}
```

### 각 기억 클래스의 특성 요약

| 기억 클래스       | 예약어      | 저장 위치         | 범위                | 생명 주기           | 초기화 특징                   |
|-----------------|-----------|-----------------|-------------------|-------------------|-------------------------|
| 자동 변수        | auto      | 스택            | 블록/함수 내       | 블록/함수 종료 시 소멸 | 초기화하지 않으면 쓰레기 값      |
| 레지스터 변수     | register  | 레지스터         | 블록/함수 내       | 블록/함수 종료 시 소멸 | 주소 연산자 사용 불가           |
| 정적 변수 (내부)  | static    | 데이터 영역       | 블록/함수 내       | 프로그램 종료 시까지   | 초기화하지 않으면 0으로 초기화   |
| 정적 변수 (외부)  | static    | 데이터 영역       | 파일 내            | 프로그램 종료 시까지   | 초기화하지 않으면 0으로 초기화   |
| 외부 변수        | extern    | 데이터 영역       | 모든 파일에서 참조 가능 | 프로그램 종료 시까지   | 초기화하지 않으면 0으로 초기화   |

각각의 기억 클래스는 특정한 상황에서 적합하게 사용될 수 있으며, 변수의 생명 주기와 범위를 정확하게 이해하고 사용하면 더 효율적이고 안정적인 프로그램을 작성할 수 있습니다.


## roadmap

{{site.data.alerts.details}}
| 강의번호 | 강의명 | 상태 | 시간 |
|--------|---------|------|------|
| 1강    | 001 운영체제의 개념 | 미리보기 | 7분 |
| 2강    | 002 프로세스 관리 | | 5분 |
| 3강    | 003 스케줄링 | | 15분 |
| 4강    | 004 병행 프로세스와 상호 배제 | | 4분 |
| 5강    | 005 기억장치 관리 | | 13분 |
| 6강    | 006 디스크 스케줄링 | | 5분 |
| 7강    | 007 정보 관리 | | 7분 |
| 8강    | 008 분산 운영체제 | | 9분 |
| 9강    | 009 운영체제의 실제 | | 10분 |
| 10강   | 010 정보 통신의 기본 | | 9분 |
| 11강   | 011 정보 전송 기술 | | 11분 |
| 12강   | 012 전송 방식 / 전송 제어 | | 11분 |
| 13강   | 013 통신 프로토콜 | | 11분 |
| 14강   | 014 정보 통신망 기술 | | 13분 |
| 15강   | 015 소프트웨어 생명 주기 | | 12분 |
| 16강   | 016 소프트웨어 개발 방법론 | | 11분 |
| 17강   | 017 스크럼(Scrum) 기법 | | 7분 |
| 18강   | 018 XP(eXtreme Programming) 기법 | | 8분 |
| 19강   | 019 요구사항 정의 | | 9분 |
| 20강   | 020 요구사항 분석 | | 13분 |
| 21강   | 021 요구사항 분석 CASE와 HIPO | | 8분 |
| 22강   | 022 UML(Unified Modeling Language) | | 10분 |
| 23강   | 023 주요 UML 다이어그램 | | 12분 |
| 24강   | 024 소프트웨어 아키텍처 | | 16분 |
| 25강   | 025 아키텍처 패턴 | | 12분 |
| 26강   | 026 객체지향(Object-Oriented) | | 16분 |
| 27강   | 027 객체지향 분석 및 설계 | | 9분 |
| 28강   | 028 디자인 패턴 | | 18분 |
| 29강   | 029 개발 지원 도구 | | 7분 |
| 30강   | 030 애플리케이션 테스트 | | 5분 |
| 31강   | 031 애플리케이션 테스트의 분류 | | 5분 |
| 32강   | 032 테스트 기법에 따른 애플리케이션 테스트 | | 11분 |
| 33강   | 033 개발 단계에 따른 애플리케이션 테스트 | | 7분 |
| 34강   | 034 통합 테스트 | | 9분 |
| 35강   | 035 결함 관리 | | 8분 |
| 36강   | 036 사용자 인터페이스 | | 10분 |
| 37강   | 037 UI 표준 및 지침 | | 9분 |
| 38강   | 038 UI 설계 도구 | | 6분 |
| 39강   | 039 UI 테스트 기법의 종류 | | 4분 |
| 40강   | 040 소프트웨어 버전 등록 | | 6분 |
| 41강   | 041 소프트웨어 버전 관리 도구 | | 8분 |
| 42강   | 042 빌드 자동화 도구 | | 3분 |
| 43강   | 043 SW / 보안 관련 신기술 | | 8분 |
| 44강   | 044 HW 관련 신기술 | | 5분 |
| 45강   | 045 DB 관련 신기술 | | 6분 |
| 46강   | 046 네트워크 관련 신기술 | | 11분 |
| 47강   | 047 데이터 타입 | 미리보기 | 12분 |
| 48강   | 048 변수 | | 22분 |
| 49강   | 049 연산자 | | 37분 |
| 50강   | 050 데이터 입ㆍ출력 | | 39분 |
| 51강   | 051 제어문 | | 14분 |
| 52강   | 052 반복문 | | 17분 |
| 53강   | 053 배열과 문자열 | | 26분 |
| 54강   | 054 포인터 | | 20분 |
| 55강   | 055 사용자 정의 함수 | | 5분 |
| 56강   | 056 Python의 기초 | | 23분 |
| 57강   | 057 Python의 활용 | | 23분 |
| 58강   | 058 웹 프로그래밍 언어 - HTML | | 13분 |
| 59강   | 059 웹 프로그래밍 언어 - JavaScript | | 8분 |
| 60강   | 060 절차적 프로그래밍 언어 | | 6분 |
| 61강   | 061 객체지향 프로그래밍 언어 | | 13분 |
| 62강   | 062 스크립트 언어 | | 6분 |
| 63강   | 063 라이브러리 | | 6분 |
| 64강   | 064 예외 처리 | | 7분 |
| 65강   | 065 프로토타입 | | 4분 |
| 66강   | 066 개발 환경 구축 | | 13분 |
| 67강   | 067 서버 개발 | | 9분 |
| 68강   | 068 모듈 | | 11분 |
| 69강   | 069 공통 모듈 | | 3분 |
| 70강   | 070 보안 및 API | | 9분 |
| 71강   | 071 자료 구조 | 미리보기 | 20분 |
| 72강   | 072 트리(Tree) | | 20분 |
| 73강   | 073 정렬(Sort) | | 22분 |
| 74강   | 074 검색 - 이분 검색 / 해싱 | | 16분 |
| 75강   | 075 데이터베이스 개요 | | 12분 |
| 76강   | 076 데이터베이스 설계 | | 31분 |
| 77강   | 077 데이터 모델의 개념 | | 12분 |
| 78강   | 078 E - R(개체 - 관계) 모델 | | 6분 |
| 79강   | 079 관계형 데이터베이스의 구조 | | 9분 |
| 80강   | 080 관계형 데이터베이스의 제약 조건 - 키(Key) | | 9분 |
| 81강   | 081 관계형 데이터베이스의 제약 조건 - 무결성 | | 12분 |
| 82강   | 082 관계대수 및 관계해석 | | 5분 |
| 83강   | 083 정규화(Normalization) | | 20분 |
| 84강   | 084 반정규화(Denormalization) | | 12분 |
| 85강   | 085 인덱스 | | 18분 |
| 86강   | 086 뷰(View) | | 11분 |
| 87강   | 087 시스템 카탈로그 / 트랜잭션 | | 3분 |
| 88강   | 088 SQL의 개념 | | 6분 |
| 89강   | 089 DDL | | 18분 |
| 90강   | 090 DCL | | 12분 |
| 91강   | 091 DML | | 7분 |
| 92강   | 092 DML - SELECT-1 | | 18분 |
| 93강   | 093 DML - SELECT-2 | | 13분 |
| 94강   | 094 DML - JOIN | | 16분 |
| 95강   | 095 절차형 SQL | | 4분 |
| 96강   | 096 프로시저(Procedure) | | 6분 |
| 97강   | 097 쿼리 성능 최적화 | | 16분 |

{{site.data.alerts.ended}}

{% include taglogic.html %}

{% include links.html %}

{% include commento.html %}

{{site.data.alerts.hr_shaded}}
