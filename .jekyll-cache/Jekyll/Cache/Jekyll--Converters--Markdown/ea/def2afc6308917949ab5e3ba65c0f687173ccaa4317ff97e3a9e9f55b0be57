I"Ô<h2 id="bash-pipeline">Bash pipeline</h2>

<h3 id="bash-automation-is-simple-and-delivers-any-job-scripted-to-perform-i-love-it-because-it-touches-on-the-processpid-of-a-task">Bash automation is simple and delivers any job scripted to perform. I love it because it touches on the process/pid of a task.</h3>

<h3 id="github-repo">github repo</h3>
<p><a href="https://github.com/aiegoo/automation">automation</a></p>

<h3 id="udemy-course-list">udemy course list</h3>
<ul>
  <li>Linux shell scripting: a project based approach to learning <a href="https://github.com/aiegoo/udemy/wiki/devop3">udemywiki</a></li>
  <li>Bash shell scripting and automation <a href="https://github.com/aiegoo/udemy/wiki/devop26">udemywiki</a></li>
  <li>Intro to linux shell scripting <a href="https://github.com/aiegoo/udemy/wiki/devop29">udemywiki</a></li>
</ul>

<p>Below is codebase Iâ€™ve been working on since October 2019, eventually ended up in an app called Spire. From stage 1 (https://github.com/aiegoo/automation/wiki/Stage1), stage 2 (https://github.com/aiegoo/automation/wiki/stage2) to Spire (master branch), overwriting contents has become sophisticated and its codes are wrap up into a single executable file.  Here is the instruction how to set up for demonstration;</p>
<hr />

<hr />

<h1 id="spire">Spire</h1>
<p>A Very Simple Automation/Command &amp; Control Solution</p>

<h1 id="overview">Overview</h1>
<p>Spire was designed to be flexible, extensible, fast and also easy to set up, use and understand.
It is extremely portable because it is fully confined to a single directory.
For configuration, it uses a combination of YAML and plaintext files.</p>

<p>Spire consists of two programs:</p>
<ul>
  <li>server-update</li>
  <li>slave</li>
</ul>

<h1 id="server-update">server-update</h1>
<p>Server-update takes two arguments:</p>

<ul>
  <li>Slave group containing a list of slaves to send requests to</li>
  <li>Name of the script file which the slaves should look for and execute</li>
</ul>

<p>All slaves, along with groups which they belong to, are specified in a <i>slavelist.yaml</i> file.</p>

<h1 id="slavelistyaml">slavelist.yaml</h1>
<p><i>Slavelist.yaml</i> file is parsed by server-update in order to determine which slaves to send a POST request to.
The file is organized as a list of groups, each having a name and a list of slaves which belong to that group.</p>

<p>For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
groups:
 - name:	Local
   slaves:
    - ip:	http://127.0.0.1
    - ip:	http://localhost

 - name:	Remote
   slaves:
    - ip:	http://example.com
...
</code></pre></div></div>

<p>It is possible to, for example, run a script called example.sh only on the Local group by running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./server-update Local example.sh
</code></pre></div></div>

<p>Alternatively, it is possible to, instead of specifying a group name, tell the program to run a certain script on all groups like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./server-update all example.sh
</code></pre></div></div>

<h1 id="slave">slave</h1>
<p>Slave is a web server which listens on port 10000.
Slave can send and receive data only through a POST request. The data it receives is a script name which it then looks for in the Scripts folder, located within the same directory as the slave program itself. If it finds the script in question, it will attempt to execute it within a separate process. If it succeeds, it will notify the sender that the script was executed successfully; Alternatively, it will notify the sender that something went wrong or that the script in question was not found.</p>

<p>It is important to note that all scripts should have a proper #! line, along with executable permissions. If they do not, the slave will catch and log an error.</p>

<h1 id="secrettxt">secret.txt</h1>
<p><i>Secret.txt</i> file should be filled with arbitrary, random data supplied by the user. It is used for secure hashing of data which is to be transmitted over the network. It should be located within the same directory as the programs.</p>

<p>Server-update transmits data in a form of a SHA256 hash. When a script name is specified, for example <i>example.sh</i>, the name is concatenated with the contents of the local <i>secret.txt</i> file.
A SHA256 hash is then made out of the aforementioned combination and sent to the slave via a POST request.</p>

<p>The slave receives the SHA256 hash. It then reads its own secret.txt file and begins going through all of the scripts in the Scripts folder. It concatenates the contents of its own <i>secret.txt</i> file with each script name it finds in the Scripts folder. If it finds a SHA256 hash that matches the one sent to it via the POST request, it knows that it has found the script which it should execute.</p>

<p><b><i>For this exchange to work, secret.txt files should be identical on both the server-update side and on the slave side. If they are not, the slave will never find a matching hash and will, therefore, notify the sender that it was unable to find the script in question, even if that script really exists.</i></b></p>

<h1 id="tldr">tl;dr</h1>

<p>The files needed for server-update are:</p>
<ul>
  <li>slavelist.yaml</li>
  <li>secret.txt</li>
</ul>

<p>The files and folders needed for slave are:</p>
<ul>
  <li>Scripts (folder)</li>
  <li>Script files within the Scripts folder (with proper permissions and #! lines)</li>
  <li>secret.txt</li>
</ul>

<p>Both secret.txt files on the server-update side and the slave side should be identical.
All files should be located within the same directory as the programs.</p>

<h2 id="bash-cli">bash cli</h2>

<h3 id="to-add-texts-to-the-head-of-a-file">to add texts to the head of a file</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'task goes here'</span> | <span class="nb">cat</span> - todo.txt | <span class="nb">tee </span>todo.txt
</code></pre></div></div>

<h3 id="to-sync-local-with-servers">to sync local with servers</h3>

<blockquote>
  <p>Deploy your Generated Site
In the previous step you created a stand-alone version of your site built from static HTML files. These files, which reside in output_prod, need to be uploaded to your publicly-accessible web server.</p>
</blockquote>

<blockquote>
  <p>Some common options are covered here: 
rsync to your own server</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsync <span class="nt">-avze</span> <span class="s1">'ssh -p 999'</span> output_prod/ user@example.com:public_html
</code></pre></div></div>

<blockquote>
  <p>You might want to use the â€“delete option to also delete files that got removed. Always make sure that there are no other files in the target directory that you do not want to be deleted. When in doubt, try with the â€“dry-run/-n flag first and check what rsync would do.</p>
</blockquote>

<blockquote>
  <p>GitHub
For GitHub pages, you will commit the rendered files in a git repository. Please refer to the official instructions on GitHub pages.</p>
</blockquote>

<blockquote>
  <p>Amazon S3 bucket
The skeleton site comes with a s3-publish.sh script which you may edit and use to upload to your bucket. You will need to install the s3cmd utility in your system for this script to work.</p>
</blockquote>
:ET